---
aliases:
  - שיטת אויילר
  - שיטת רונגה-קוטה
  - שגיאה כללית במד"ר
  - שגיאה מקומית במד"ר
  - פתרון נומרי למערכת מד"ר
  - פתרון נומרי למד"ר
  - שיטת הירי
---
# מבוא
אנו כבר מכירים ש[[DEQ1_001 מבוא#משוואה דיפרנציאלית רגילה|מד"רים]] יכולים להיות קשים לפתרונות אנליטיים, ובעוד [[PDE1_001 הקדמה ומשוואות מסדר ראשון#משוואה דיפרנציאלית חלקית|מדח"ים]] לרוב לא פתירים בכלל, חוץ מכמה משפחות מסוימות. לכן, הביקוש לפתרונות נומריים של משוואות דיפרנציאליות הוא מאוד גבוה.

# שיטת אויילר

**שיטת אויילר**, הידועה גם בשם **שיטת אויילר לפנים**, היא השיטה הפשוטה ביותר לפתרון מד"ר עם תנאי התחלה.
אנו נעסוק בפתרון מד"ר מהצורה:
$$y'=f(t,y)$$
כאשר $f$ נתון, ונרצה למצוא את $y$.

## פיתוח השיטה
נגדיר את הנקודות:
$${t}_{0}=a,\, \quad t_{i}=a+ih,\, \quad i=0,1,2,\dots ,N$$
כאשר $h=\dfrac{b-a}{N}$ הוא גודל הצעד. לפי [[NUM1_010 גזירה נומרית#שיטות בשתי נקודות|שיטת ההפרשים לפנים]], הנגזרת מקיימת:
$$y'(t_{i})= \dfrac{y(t_{i+1})-y(t_{i})}{h}-\dfrac{h}{2}y''(\xi_{i})+\mathcal{O}(h^{2})$$
נציב במד"ר, ונקבל ביטוי ל-$y(t_{i+1})$:
$$y(t_{i+1})=y(t_{i})+hf(t_{i},y(t_{i}))+\dfrac{h^{2}}{2}y''(\xi_{i})+\mathcal{O}(h^{3})$$
 נסמן את הפתרון המשוער של $y(t_{i})$ ב-$y_{i}$, ונקבל את **שיטת אויילר לפנים**, שמשערת את הפתרון $\{ y_{i} \}_{i=0}^{N}$ בצורה הבאה:
$$\boxed {
\begin{aligned}
 & {y}_{0}=c \\
 & y_{i+1}=y_{i}+hf(t_{i},y_{i}),\, \quad i=0,1,\dots ,N-1
\end{aligned}
 }$$
כאשר ${y}_{0}=c$ הוא התנאי התחלה שלנו.

![[Screenshot_20240322_182502_OneDrive.jpg|book]]
> שני שלבים של שיטת אוילר לפנים. הפיתרון המדויק הוא הגרף הרציף. הערכים הנומריים שהתקבלו בשיטת אוילר מוקפים בעיגול. 



השגיאה (האמיתית) של שיטה זו וכל שיטה לפתרון נומרי של מד"ר נקראת ה**שגיאה הכללית/גלובלית**, והיא נתונה ע"י:
$$e_{i}=y(t_{i})-y_{i}$$
נגדיר עוד שגיאה לשיטות נומריות לפתרון מד"ר: 
>[!def] הגדרה: 
 >
**שגיאה מקומית $d_{i}$.** שגיאה מקומית היא השגיאה שנוצרת בצעד יחיד של השיטה. כלומר:
$$d_{i}={y(t_{i+1})-y_{i+1}}$$

מהפיתוח שביצענו עבור שיטת אויילר, ניתן להראות כי:
$$\boxed {
d_{i}=\dfrac{h^{2}}{2}y''(\xi_{i})+\mathcal{O}(h^{3})
 }$$
כאשר $t_{i}\leq \xi_{i}\leq \xi_{t+1}$. נסיק כי לשיטה זו שגיאה מקומית מסדר $2$.

נרצה לדעת מה סדר השגיאה של השגיאה הכללית. ראינו כי השגיאה המקומית היא מסדר $h^{2}$. מספר הצעדים מחושב באופן מאוד פשוט ע"י $\dfrac{{t}_{1}-{t}_{0}}{h}$, שהוא פרופורציונאלי ל-$\dfrac{1}{h}$. לכן, נסיק כי השגיאה הכללית תהיה פרופורציונאלית ל-$h$. נוכל גם להראות זאת בצורה אנליטית, שאת הפיתוח שלא אין לנו כוח להראות:
$$\boxed {
\left|e_{i}\right|=\left|y(t_{i})-y_{i}\right|\leq \dfrac{hM}{2L}(e^{L(t_{i}-t_{0})}-1)
 }$$
כאשר $M=\left|\max_{}y''(t)\right|$ בקטע, ו- $L=\left|\max_{}f_{y}(t,y)\right|$ בקטע.


>[!example] דוגמה: 
 >נביט במד"ר הבא:
 >$$y'=y,\, \quad y(0)=1$$
 >הפתרון האמיתי הוא $y(t)=e^{t}$. נפתור בשיטת אויילר:
 >$$\begin{aligned}
 & {y}_{0}=1 \\
 & y_{i+1}=y_{i}+hy_{i}=(1+h)y_{i},\, \quad i=0,1,2\dots 
\end{aligned}$$
>נקבל את הפתרונות הבאים עבור $h=0.2$ ($y(t_{i})$ הוא הפתרון האמיתי, ואילו $y_{i}$ הוא הפתרון המשוער):
>$$\begin{array}{c|c}
t_{i} & y(t_{i}) & y_{i}  & \text{Error}\\
\hline 0 & 1.000 & 1.000 & 0.0 \\
0.2 & 1.221 & 1.200  & 0.021\\
0.4 & 1.492 & 1.440 & 0.052 \\
0.6 & 1.822 & 1.728 & 0.094
\end{array}$$
>עבור $h=0.1$:
>$$\begin{array}{c|c}
t_{i} & y(t_{i}) & y_{i} & \text{Error} \\
\hline 0 & 1.000 & 1.000 & 0.0 \\
0.1 & 1.105 &  1.100 & 0.005 \\
0.2 & 1.221 & 1.210 & 0.011 \\
0.3 & 1.350 & 1.331 & 0.019 \\
0.4 & 1.492 & 1.464 & 0.028 \\
0.5 & 1.694 & 1.611 & 0.038 \\
0.6 & 1.822 & 1.772 & 0.051
\end{array}$$
>נשים לב שהשגיאה שלנו קטנה בערך פי $2$ כאשר $h$ קטן באותה מידה. בנוסף, השגיאה שלנו גדלה ככל ש-$t_{i}$ גדל. 


# שיטות רונגה-קוטה (Runge-Kutta)
שיטת אויילר בעלת שגיאה מסדר ראשון. לכן, היא שיטה לא יעילה כל כך - הצעד $h$ שלוקחים כל פעם צריך להיות מאוד קטן כדי לקבל פתרון שימושי.

כדי להתחיל להסביר שיטות עם סדר שגיאה יותר גבוה, נביט במד"ר $y'=f(t,y)$, בצעד אחד, מ-$t_{i}$ ל-$t_{i+1}$. נניח כי הקירוב $y_{i}$ עבור $y(t_{i})$ ידוע, ונפתח שיטות לקבל את קירוב $y_{i+1}$ ל-$y(t_{i+1})$ בנקודה הבאה $t_{i+1}$.

שיטה מאוד נפוצה היא להשתמש רק במידע בצעד הנוכחי - $[t_{i},t_{i+1}]$. **שיטת רונגה-קוטה** היא שיטה בה מבצעים חישובים חוזרים כדי בצעד אחד כדי לקבל קירוב מסדר יותר גבוה.

![[Screenshot_20240322_215700_OneDrive.jpg|book|400]]
> שיטת רונגה-קוטה: חישובים חוזרים של הפונקציה $f$ בקטע $[t_{i},t_{i+1}]$ משולבים כדי לקבל קירוב יותר טוב $y_{i+1}$ ב-$t_{i+1}$.

כעת נפתח שאת שיטות הטרפז ושיטות הביניים שהן כולן סוגים שונים של שיטות רונגה-קוטה.
## שיטת אויילר המתוקנת
אם נבצע אינטגרציה על המד"ר שלנו לפי $t$, בקטע $[t_{i},t_{i+1}]$, נקבל:
$$\int_{t}^{t_{i+1}} y'(t) \, \mathrm{d}t=\int_{t_{i}}^{t_{i+1}} f(t,y(t)) \, \mathrm{d}x  $$

לפי [[CAL1_008 אינטגרל מסוים#המשפט היסודי של החדו"א|המשפט היסודי של החדוא]], נקבל:
$$y(t_{i+1})-y(t_{i})=\int_{t_{i}}^{t_{i+1}} f(t,y(t)) \, \mathrm{d}t $$

נעביר אגפים:
$$y(t_{i+1})=y(t_{i})+\int_{t_{i}}^{t_{i+1}} f(t,y(t)) \, \mathrm{d}t $$
כדי לחשב את האינטגרל, ניעזר בקירוב שלו לפי [[NUM1_009 אינטגרציה נומרית#פיתוח שיטות בסיסיות|שיטת הטרפזים]], ונקבל את **שיטת הטרפזים הסתומה**:
$$\boxed {
y_{i+1}=y_{i}+\dfrac{h}{2}[f(t_{i},y_{i})+f(t_{i+1},y_{i+1})]
 }$$
קוראים לשיטה זו סתומה כי החישוב של $y_{i+1}$ תלוי ב-$y_{i+1}$ בעצמו (בביטוי האחרון מצד ימין). לכן, יש הפרדה בין שיטות סתומות לשיטות לא סתומות. נרצה להפוך את שיטה זו ללא סתומה, ובכך לחשב את $y_{i+1}$ יותר בפשטות.
נשתמש ב[[#שיטת אויילר]] כדי לחשב בקירוב את $y_{i+1}$:
$${Y}_{}=y_{i+1}=y_{i}+hf(t_{i},y_{i})$$
כעת נוכל להציב זאת בשיטה הסתומה, כדי לקבל את **שיטת הטרפזים**, שנקראת גם **שיטת אויילר המתוקנת**:
$$\boxed {
y_{i+1}=y_{i}+\dfrac{h}{2}[f(t_{i},y_{i})+f(t_{i+1},{Y}_{})]
 }$$

נשים לב כי שיטה זו כוללת שני חישובים של $f$ בשלב $i$. נאמר כי זוהי שיטת $\mathrm{RK}$ בשני שלבים.

השגיאה המקומית:
$$d_{i}= \dfrac{y(t_{i+1})-y(t_{i})}{h}-\dfrac{1}{2}[f(t_{i},y(t_{i})+f(t_{i+1},\hat{Y}))]$$
כאשר $\hat{Y}=y(t_{i})+hy'(t_{i})$. משגיאת שיטת הטרפזים (עבור אינטגרלים), ניתן להראות אחרי פיתוח מאוד טכני ומשעמם שהשגיאה המקומית תהיה $d_{i}=\mathcal{O}(h^{2})$, כלומר מסדר $2$.

## שיטת אויילר המשופרת
נוכל גם לקבל קירוב עבור האינטגרל בעזרת קירוב ביניים, כדי לקבל את **שיטת הביניים הסתומה**:
$$y_{i+1}=y_{i}+hf(t_{i+1/2},\, y_{i+1/2})$$
כאשר:
$$t_{i+1/2}=\dfrac{t_{i}+t_{i+1}}{2}=t_{i}+\dfrac{h}{2},\, \quad \quad y_{i+1/2}=\dfrac{y_{i}+y_{i+1}}{2}$$
נשתמש בשיטת אויילר כדי למצוא קירוב ל-$y_{i+1/2}$:
$$Y=y_i+\dfrac{h}{2}f(t_{i},y_{i})$$
נציב, ונקבל את **שיטת הביניים**, שנקראת גם **שיטת שיטת אויילר המשופרת**:
$$\boxed {
y_{i+1}=y_{i}+hf(t_{i+1/2},\, Y)
 }$$
 כמו מקודם, זוהי שיטת $\mathrm{RK}$ בשני שלבים, עם שגיאה מסדר $2$.

## שיטת רונגה-קוטה הקלאסית
**שיטת רונגה-קוטה** הקלאסית מבוססת על אינטגרציה לפי [[NUM1_009 אינטגרציה נומרית#פיתוח שיטות בסיסיות|שיטת סימפסון]], ויש בה $4$ שלבים, כדי לקבל דיוק מסדר $\mathcal{O}(h^{4})$. היא נתונה ע"י:
$$\boxed {
\begin{aligned}
 & {Y}_{1}=y_{i} \\[1ex]
 & {Y}_{2}=y_{i}+\dfrac{h}{2}f(t_{i},{Y}_{1}) \\
 & {Y}_{3}=y_{i}+\dfrac{h}{2}f(t_{i+1/2}{Y}_{2}) \\[1ex]
 & {Y}_{4}=y_{i}+hf(t_{i+1/2},{Y}_{3}) \\[2ex]
 & 
y_{i+1}=y_{i}+\dfrac{h}{6}[f(t_{i},{Y}_{1})+2f(t_{i+1/2},{Y}_{2}) \\
 & \quad \quad \quad +2f(t_{i+1/2},{Y}_{3})+f(t_{i+1},{Y}_{4})]
\end{aligned}
 }$$

הפיתוח של השיטה וההוכחה שהשגיאה של היא מסדר $4$ היא מסובכת שאפילו לספר לא היה כוח להראות אותו.

נהוג לסמן $K_{j}=f(t_{j},Y_{j})$, ואז השיטה הופכת להיות:
$$\boxed{\begin{aligned}
 & {K}_{1}=f(t_{i},\, {y}_{i}) \\
 & {K}_{2}=f\left( t_{i+1/2},\, y_{i}+\dfrac{h}{2}{K}_{1} \right) \\
 & {K}_{3}=f\left( t_{i+1/2},\, y_{i}+\dfrac{h}{2}{K}_{2} \right) \\
 & {K}_{4}=f(t_{i+1},\, y_{i}+h{K}_{3}) \\[2ex]
 & y_{i+1}=y_{i}+\dfrac{h}{6}[{K}_{1}+2{K}_{2}+2{K}_{3}+{K}_{4}]
\end{aligned} }$$

להלן פונקציית `MATLAB` הכתובה עבור *מערכת* מד"ר. שימו לב שבמקום לחשב את $Y_{j}$, מחושב הערך $K_{j}=f(t_{j},Y_{j})$:
```matlab
function [t,y] = rk4(f,tspan,y0,h)
	%
	% function [t,y] = rk4(f,tspan,y0,h)
	%
	% A simple integration routine to solve the
	% initial value ODE y’ = f(t,y), y(a) = y0,
	% using the classical 4-stage Runge-Kutta method
	% with a fixed step size h.
	% tspan = [a b] is the integration interval.
	% Note that y and f can be vector functions
	
	y0 = y0(:); % make sure y0 is a column vector
	m = length(y0); % problem size
	t = tspan(1):h:tspan(2); % output abscissae
	N = length(t)-1; % number of steps
	y = zeros(m,N+1);
	y(:,1) = y0; % initialize
	
	% Integrate
	for i=1:N
		% Calculate the four stages
		K1 = feval(f, t(i),y(:,i) );
		K2 = feval(f, t(i)+.5*h, y(:,i)+.5*h*K1);
		K3 = feval(f, t(i)+.5*h, y(:,i)+.5*h*K2);
		K4 = feval(f, t(i)+h, y(:,i)+h*K3 );
	
	% Evaluate approximate solution at next step
		y(:,i+1) = y(:,i) + h/6 *(K1+2*K2+2*K3+K4);
	end
end
```

>[!example] דוגמה: 
 >נביט במד"ר הבא:
 >$$y'=-y^{2},\, \quad \quad y(1)=1$$
 >הפתרון האמיתי הוא $y(t)=\dfrac{1}{t}$. נראה את השגיאות ב-$t=10$:
>$$\begin{array}{c|c} 
h & \text{Euler} & \mathrm{RK}2 & \mathrm{RK}4 \\
\hline 0.2 & \pu{4.7e-3} & \pu{3.3e-4} & \pu{2.0e-7} \\
\hline 0.1 & \pu{2.3e-3} & \pu{7.4e-5} & \pu{1.4e-8} \\
\hline 0.05 & \pu{1.2e-3} & \pu{1.8e-5} & \pu{8.6e-10} \\
\hline 0.02 & \pu{4.6e-4} & \pu{2.8e-6} & \pu{2.2e-11} \\
\hline 0.01 & \pu{2.3e-4} & \pu{6.8e-7} & \pu{1.4e-12}
\end{array}$$
>ניתן באמת לראות שכל השיטות נותנות שגיאות מסדר $1,2,4$ בהתאמה.

# מערכת משוואות דיפרנציאליות

כאשר נתונה לנו [[DEQ1_010 מערכת משוואות#מערכת משוואות דיפרנציאליות|מערכת משוואות דיפרנציאליות]] עם תנאי התחלה:

$$\begin{aligned}
 & {y}_{1}'(t)=\bar{f}(t,{y}_{1}) \\
 & {y}_{2}'(t)=\bar{f}(t,{y}_{2}) &  \\
 &  \quad \quad \ \ \, \vdots \\ 
\end{aligned} \quad \quad \begin{aligned}
 & {y}_{1}({t}_{0})={y}_{0} \\
 & {y}_{2}({t}_{0})={y}_{1} \\
 & \quad \quad \ \ \ \ \vdots 
\end{aligned}$$

נוכל לכתוב אותה בצורה הוקטורית הבאה:
$$\begin{aligned}
 & \bar{y}'(t)=\bar{f}(t,\bar{y}) \\
 & \bar{y}({t}_{0})=\bar{y}_{0}
\end{aligned}$$
כדי לפתור אותה, נוכל פשוט להשתמש באותם השיטות שהצגנו מקודם, רק בהצגתם הוקטורית.

>[!example] דוגמה: 
 >נפעיל את שיטת [[#שיטת רונגה-קוטה הקלאסית]] על הבעיה הבאה:
 >$$\begin{aligned}
 & y'_{1}=0.25{y}_{1}-0.01{y}_{1}{y}_{2} &  & {y}_{1}(0)=80 \\
 & y'_{2}=-{y}_{2}+0.01{y}_{1}{y}_{2} &  & {y}_{2}(0)=30
\end{aligned}$$
>נמצא את הפתרון בקטע $[0,100]$, עם גודל צעד $h=0.01$. קוד `MATLAB`:
> ```matlab
> y0 = [80,30]’; % initial data
> tspan = [0,100]; % integration interval
> h = .01; % constant step size
> [tout,yout] = rk4(@func,tspan,y0,h);
> figure(1)
> plot(tout,yout)
> xlabel(’t’)
> ylabel(’y’)
> legend(’y_1’,’y_2’)
> 
> figure(2)
> plot(yout(1,:),yout(2,:))
> xlabel(’y_1’)
> ylabel(’y_2’)
> 
> function f = func(t,y)
> 	a = .25; b = -.01; c = -1; d = .01;
> 	f(1) = a*y(1) + b*y(1)*y(2);
> 	f(2) = c*y(2) + d*y(1)*y(2);
> ```
>הפתרון מוצג באיור הבא:
>![[Pasted image 20240329094801.png|book]]
>>הפלט של הבעיה הנ"ל.




---
**תרגיל**:
נתונה המשוואה הדיפרנציאלית הבאה מסדר $3$ עם תנאי התחלה:
$$\begin{aligned}
 & t^{3}t'''-y^{2}y''-2ty'-3y-t^{4}=0 \\
 & y(2)=16 \\
 & y'(2)=32 \\
 & y''(2)=48
\end{aligned}$$
כתוב את המשוואה הנ"ל כמערכת משוואות מסדר ראשון עם תנאי התחלה מתאימים. רשום את המשוואה בצורה וקטורית.

**פתרון**:
נבצע [[DEQ1_006 משוואות לינאריות הומוגניות מסדר גבוה#אלגוריתם שיטת הורדת הסדר|הורדת הסדר]]:
$$\begin{aligned}
 & {y}_{1}(t)=y(t) \\
 & {y}_{2}(t)=y'(t) \\
 & {y}_{3}(t)=y''(t)
\end{aligned}$$
נציב במשוואה:
$$\begin{gathered}
t^{3}{y}_{3}'-t^{2}{y}_{3}-2t{y}_{2}-3{y}_{1}-t^{4}=0 \\[1ex]
{y}_{3}'=\dfrac{1}{t^{3}}(t^{2}{y}_{3}(t)+2t{y}_{2}(t)+3{y}_{1}(t)+t^{4})
\end{gathered}$$
לכן הבעיה:
$$\begin{aligned}
 & {y}_{1}'(t)={y}_{2} \\
 & {y}_{2}'(t)={y}_{3} \\
 & {y}_{3}'(t)=\dfrac{1}{t^{3}}(t^{2}{y}_{3}+2t{y}_{2}+3{y}_{1}+t^{4})
\end{aligned}\quad \quad \begin{aligned}
 & {y}_{1}(2)=16 \\
 & {y}_{2}(2)=32 \\
 & {y}_{3}(2)=48
\end{aligned}$$
בצורה וקטורית:
$$\boxed {
\bar{y}(t)=\begin{pmatrix}
{y}_{2} \\
{y}_{3} \\
\dfrac{1}{t^{3}}(t^{2}{y}_{3}+2t{y}_{2}+3{y}_{1}+t^{4})
\end{pmatrix}\quad \quad \bar{y}(2)=\begin{pmatrix}
16 \\
32 \\
48
\end{pmatrix}
 }$$

---

# מד"ר עם תנאי שפה
בכללי, מערכת מד"ר עם $m$ משוואות הנתונה בצורה הבאה
$$\bar{y}'=\bar{f}(t,\bar{y}),\, \quad a<t<b$$
תניב מרחב פתרונות ב-$m$ פרמטרים ([[ALG1_006 בסיס וממד#בסיס וממד|ממד]] $m$). כדי לקבל פתרון יחיד, דרושים $m$ אילוצים שכולם נתונים עבור נקודה ספציפית ${t}_{0}$, כמו תנאי התחלה שראינו מקודם. לפי קיום ויחידות, כאשר נתונים $m$ תנאי התחלה, למד"ר קיים פתרון אמיתי ויחיד.
אבל, נוצרת בעיה כאשר במקום תנאי התחלה נתונים לנו [[PDE1_001 הקדמה ומשוואות מסדר ראשון#תנאי שפה|תנאי שפה]], כלומר שנתונים לנו $l$ אילוצים ב-$a$, ו-$m-l$ אילוצים ב-$b$. דוגמה לכך היא [[PDE1_005 בעיית שטורם ליוביל|בעיית שטורם ליוביל]].

>[!example] דוגמה: 
 >את המד"ר:
 >$$\begin{aligned}
v''+e^{v}=0, &  &  0<t<1
\end{aligned}$$
 >נוכל לרשום כמערכת משוואות:
 >$$\begin{aligned}
\bar{y}\equiv \begin{pmatrix}
{y}_{1} \\
{y}_{2}
\end{pmatrix}=\begin{pmatrix}
v \\
v'
\end{pmatrix} &  & \bar{f}(t,\bar{y})=\begin{pmatrix}
{y}_{2} \\
-e^{{y}_{1}}
\end{pmatrix}
\end{aligned}$$
אם היה נתון לנו תנאי התחלה, כמו למשל ${y}_{1}(0)={y}_{2}(0)=0$, אז קיים פתרון אמיתי ויחיד. אבל, אם היו נתונים לנו תנאי שפה כמו:
$${y}_{1}(0)=0,\,  \quad {y}_{1}(1)=0$$
אז למשוואה יש כעת שני פתרונות שונים:
>![[Pasted image 20240329111210.png|book]]
>>שני פתרונות שונים לבעיה $v''+e^{v}=0$ עם תנאי שפה.


# שיטת הירי (Shooting method)
**בשיטת הירי** אנו הופכים את הבעיית שפה שלנו לבעיית התחלה. היא כוללת מציאת פתרונות לבעיית התחלה עם תנאי התחלה שונים, עד שמוצאים פתרון שמקיים את תנאי השפה.
במונחים פשוטים, אנו "יורים" בכיוונים שונים מתנאי שפה אחד, עד שאנו "פוגעים" במטרה, שהוא התנאי שפה השני שלנו.

![[Pasted image 20240329115745.png|book]]
>פתרון בעזרת שיטת הירי של הדוגמה הקודמת. נשים לב שעבור "ירייה" בכיוונים התחלתיים ${c}_{0}$ שונים, הפתרון שלנו מתכנס לאחד משני הפתרנות של הבעיה.

אנו נתמקד בפתרון נומרי של בעיה מסדר $2$:
$$\begin{aligned}
 & y''=f(y,y',t) \\
 & y(a)=\alpha \\
 & y(b)=\beta
\end{aligned}$$
נפרק לשני מקרים - $f$ לינארית ו-$f$ לא לינארית.

## שיטת הירי עבור משוואה לינארית

נביט במקרה הכללי של בעיה לינארית מסדר $2$ עם תנאי שפה:
$$\begin{aligned}
 & y''=p(t)y'+q(t)y+r(t) \\
 & y(a)=\alpha \\
 & y(b)=\beta
\end{aligned}$$

כיוון שהבעיה לינארית, נוכל למצוא פתרון עבורה בעזרת רק $2$ "ניחושים" - כלומר רק שני בעיות התחלה (${y}_{1},{y}_{2}$) עם תנאי התחלה שונים. פעם אנו "יורים" בשיפוע $0$, פעם בשיפוע $1$:
בעיה ${y}_{1}$:
$$\begin{aligned}
 & y''_{1}=p(t)y'_{1}+q(t)y_{1}+r(t) \\
 & {y}_{1}(a)=\alpha \\
 & {y}_{1}'(a)=0
\end{aligned}$$
בעיה ${y}_{2}$:
$$\begin{aligned}
 & y''_{2}=p(t)y'_{2}+q(t)y_{2}+r(t) \\
 & {y}_{2}(a)=\alpha \\
 & {y}_{2}'(a)=1
\end{aligned}$$
מאחר הבעית שפה היא לינארית, הפתרון שלה יהיה לינארי ביחס לפתרונות של הבעיות התחלה בעלי אותה המשוואה:
$$y={\lambda}_{1}{y}_{1}+{\lambda}_{2}{y}_{2}$$
נדרוש שהפתרון שלה יקיים את תנאי השפה הראשון, ${y}_{}(a)=\alpha$:
$$\alpha=y(a)={\lambda}_{1}{y}_{1}(a)+{\lambda}_{2}{y}_{2}(a)$$
מהגדרת הבעיות, ${y}_{1}(a)=\alpha,\, {y}_{2}(a)=\alpha$ ולכן:
$$\begin{gathered}
\alpha={\lambda}_{1}\alpha+{\lambda}_{2}\alpha \\
1={\lambda}_{1}+{\lambda}_{2}
\end{gathered}$$

נדרוש שהפתרון שלה יקיים את תנאי השפה השני, ${y}_{}(b)=\beta$:
$$\begin{gathered}
\beta=y(b)={\lambda}_{1}{y}_{1}(b)+{\lambda}_{2}{y}_{2}(b) \\[1ex]
\beta={\lambda}_{1}{y}_{1}(b)+(1-{\lambda}_{1}){y}_{2}(b) \\[2ex]
{\lambda}_{1}=\dfrac{\beta-{y}_{2}(b)}{{y}_{1}(b)-{y}_{2}(b)}
\end{gathered}$$
 מהסופרפוזיציה שפיתחנו מקודם:
$$\begin{aligned}
y & ={\lambda}_{1}{y}_{1}+{\lambda}_{2}{y}_{2} \\
 & = {\lambda}_{1}{y}_{1}+(1-{\lambda}_{1}){y}_{2} \\
\end{aligned}$$

אין כבר משמעות ל-$1$ ב-${\lambda}_{1}$, אז פשוט נסמן אותו $\lambda$. נסכם:
$$\boxed{\begin{aligned}
 & y={\lambda}_{}{y}_{1}+(1-{\lambda}_{}){y}_{2} \\[2ex]
 & \lambda=\dfrac{\beta-{y}_{2}(b)}{{y}_{1}(b)-{y}_{2}(b)}
\end{aligned} }$$

>[!notes] הערות: 
>1. נשים לב שהפתרון הסופי לא תלוי בבחירה בתנאי התחלה של בעיות ההתחלה שפיתחנו. כלומר, לא חובה עלינו לבחור את השיפועים $0$ ו-$1$.
 >2. יכל להיות שמבחירת תנאי ההתחלה שלנו, יקרה מצב בו ${y}_{1}(b)-{y}_{2}(b)=0$, ואז ייתאפס לנו המכנה. במקרה כזה, פשוט נחליף את תנאי ההתחלה שקבענו בפיצול הבעיה. כלומר, נבחר ${y}_{1}'(a)$ ו-${y}_{2}'(a)$ שונים, כך שהפתרונות ${y}_{1},{y}_{2}$ ישתנו.
 >


---
**תרגיל**:
פתור באמצעות שיטת הירי את הבעיה הנ"ל:
$$\begin{aligned}
 & y''+y=0 \\
 & y(0)=0 \\[1ex]
 & y\left( \dfrac{\pi}{2} \right) = 1
\end{aligned}$$

**פתרון**:
נרצה למצוא את $\lambda$:
$$\begin{aligned}
\lambda & =\dfrac{\beta-{y}_{2}(b)}{{y}_{1}(b)-{y}_{2}(b)} \\[2ex] 
 & =\dfrac{y\left( \dfrac{\pi}{2}\right)-{y}_{2}\left( \dfrac{\pi}{2} \right)}{{y}_{1}\left( \dfrac{\pi}{2} \right)-{y}_{2}\left( \dfrac{\pi}{2} \right)}
\end{aligned}$$

נבחר שיפועים התחלתיים:
$$\begin{aligned}
{y}_{1}'(0)=-1 &  & {y}_{2}'(0)=2
\end{aligned}$$
ונקבל מהפתרון ב[[#שיטת רונגה-קוטה הקלאסית]] עם $h=\dfrac{\pi}{50}$ ש:
$$\begin{aligned}
{y}_{1}\left( \dfrac{\pi}{2} \right)=-1 &  & {y}_{2}\left( \dfrac{\pi}{2} \right)=2
\end{aligned}$$

נציב בחזרה בנוסחה עבור $\lambda$ ונקבל כי:
$$\lambda=\dfrac{1}{3}$$
ולפיכך:
$$\begin{aligned}
y(t)=\dfrac{1}{3}{y}_{1}+\dfrac{2}{3}{y}_{2}
\end{aligned}$$

קוד `python`:
```python
import numpy as np
import matplotlib.pyplot as plt

# define the Runge-Kutta 4th order method for second order ODEs, that returns the solution at each step
def rk4(f, y0, t0, t1, h):
    t = t0
    y = y0
    sol = []
    while t < t1:
        k1 = h * f(t, y)
        k2 = h * f(t + h/2, y + k1/2)
        k3 = h * f(t + h/2, y + k2/2)
        k4 = h * f(t + h, y + k3)
        y = y + (k1 + 2*k2 + 2*k3 + k4)/6
        t = t + h
        sol.append(y)
    return np.array(sol)

# define the system of ODEs y''+y=0
def f(t, y):
    return np.array([y[1], -y[0]])

# Initial guesses for y'(0) = -1 and y'(0) = 2
y1_slope = -1
y2_slope = 2

# Define the interval of integration and the step size
t0 = 0
t1 = np.pi/2
h = np.pi/50

# Solve the system of ODEs using the Runge-Kutta 4th order method
y1 = rk4(f, np.array([0, y1_slope]), t0, t1, h)
y2 = rk4(f, np.array([0, y2_slope]), t0, t1, h)

# Linear superposition of the two solutions to get the solution of the ODE with y'(0) = 1
l = (y2_slope - 1)/(y2_slope - y1_slope)
y = l*y1 + (1-l)*y2

# The real solution of the ODE is y(t) = sin(t)
t = np.arange(t0, t1, h)
y_real = np.sin(t)

# Plot the y1, y2m the numerical solution and the real solution
plt.plot(t, y1[:, 0], label='y1')
plt.plot(t, y2[:, 0], label='y2')
plt.plot(t, y[:, 0], label='y: Numerical solution')
plt.plot(t, y_real, label='sint: Real solution', linestyle='--')
plt.xlabel('t')
plt.ylabel('y')
plt.title('Solution of y\'\' + y = 0')
plt.legend()
```

הפלט:
![[Technion/NUM1/NUM1_011/output.png|book]]
>הפתרונות ${y}_{1},{y}_{2}$, הפתרון הנומרי והאמיתי לבעיה $y''+y=0$, עם תנאי השפה והניחושים הנ"ל.

---

## שיטת הירי עבור משוואה לא לינארית
נביט במקרה הכללי של בעיה לא לינארית מסדר $2$ עם תנאי שפה:
$$\begin{aligned}
 & y''=f(t,y,y') \\
 & y(a)=\alpha \\
 & y(b)=\beta
\end{aligned}$$
נגדיר את הבעיה $y(t;c)$, שתפתור את בעיית ההתחלה:
$$\begin{aligned}
 & y''=f(t,y,y') \\
 & y(a)=\alpha \\
 & y'(a)=c
\end{aligned}$$
אנו רוצים למצוא עבור איזה שיפוע "ירי" $c$ נקבל ש- $y(b;c)=\beta$. כלומר, אנו נידרש למצוא [[NUM1_005 משוואות לא לינאריות במשתנה אחד#מבוא|שורש]] של המשוואה:
$$g(c)=y(b;c)-\alpha$$
כדי לפתור זאת, ניעזר בשיטות נומריות ל[[NUM1_005 משוואות לא לינאריות במשתנה אחד#מבוא|פתרון משוואות לא לינאריות]], כמו שיטת החצייה ושיטת ניוטון.

